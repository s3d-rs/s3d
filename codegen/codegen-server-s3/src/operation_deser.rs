// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub async fn parse_abort_multipart_upload_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::AbortMultipartUploadInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::abort_multipart_upload_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_abort_multipart_upload_abort_multipart_upload_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_abort_multipart_upload_abort_multipart_upload_input_request_payer(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_abort_multipart_upload_input_bucket(m0)?);
        input =
            input.set_key(crate::operation_deser::parse_str_abort_multipart_upload_input_key(m1)?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_upload_id = false;
        for (k, v) in pairs {
            if !seen_upload_id && k == "uploadId" {
                input = input.set_upload_id(
                    crate::operation_deser::parse_str_abort_multipart_upload_input_upload_id(&v)?,
                );
                seen_upload_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_complete_multipart_upload_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::CompleteMultipartUploadInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::complete_multipart_upload_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_complete_multipart_upload_complete_multipart_upload_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_multipart_upload(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_complete_multipart_upload_complete_multipart_upload_input_multipart_upload(&bytes)?
                                        }
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_complete_multipart_upload_complete_multipart_upload_input_request_payer(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_complete_multipart_upload_input_bucket(m0)?,
        );
        input = input
            .set_key(crate::operation_deser::parse_str_complete_multipart_upload_input_key(m1)?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_upload_id = false;
        for (k, v) in pairs {
            if !seen_upload_id && k == "uploadId" {
                input = input.set_upload_id(
                    crate::operation_deser::parse_str_complete_multipart_upload_input_upload_id(
                        &v,
                    )?,
                );
                seen_upload_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_copy_object_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::CopyObjectInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::copy_object_input::Builder::default();
        input = input.set_acl(
            crate::http_serde::deser_header_copy_object_copy_object_input_acl(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_bucket_key_enabled(
            crate::http_serde::deser_header_copy_object_copy_object_input_bucket_key_enabled(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_cache_control(
            crate::http_serde::deser_header_copy_object_copy_object_input_cache_control(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_content_disposition(
            crate::http_serde::deser_header_copy_object_copy_object_input_content_disposition(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_content_encoding(
            crate::http_serde::deser_header_copy_object_copy_object_input_content_encoding(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_content_language(
            crate::http_serde::deser_header_copy_object_copy_object_input_content_language(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_content_type(
            crate::http_serde::deser_header_copy_object_copy_object_input_content_type(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_copy_source(
            crate::http_serde::deser_header_copy_object_copy_object_input_copy_source(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_copy_source_if_match(
            crate::http_serde::deser_header_copy_object_copy_object_input_copy_source_if_match(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_copy_source_if_modified_since(
            crate::http_serde::deser_header_copy_object_copy_object_input_copy_source_if_modified_since(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_copy_source_if_none_match(
            crate::http_serde::deser_header_copy_object_copy_object_input_copy_source_if_none_match(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_copy_source_if_unmodified_since(
            crate::http_serde::deser_header_copy_object_copy_object_input_copy_source_if_unmodified_since(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_copy_source_sse_customer_algorithm(
            crate::http_serde::deser_header_copy_object_copy_object_input_copy_source_sse_customer_algorithm(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_copy_source_sse_customer_key(
            crate::http_serde::deser_header_copy_object_copy_object_input_copy_source_sse_customer_key(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_copy_source_sse_customer_key_md5(
            crate::http_serde::deser_header_copy_object_copy_object_input_copy_source_sse_customer_key_md5(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_copy_object_copy_object_input_expected_bucket_owner(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_expected_source_bucket_owner(
            crate::http_serde::deser_header_copy_object_copy_object_input_expected_source_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_expires(
            crate::http_serde::deser_header_copy_object_copy_object_input_expires(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_grant_full_control(
            crate::http_serde::deser_header_copy_object_copy_object_input_grant_full_control(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_grant_read(
            crate::http_serde::deser_header_copy_object_copy_object_input_grant_read(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_grant_read_acp(
            crate::http_serde::deser_header_copy_object_copy_object_input_grant_read_acp(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_grant_write_acp(
            crate::http_serde::deser_header_copy_object_copy_object_input_grant_write_acp(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_metadata_directive(
            crate::http_serde::deser_header_copy_object_copy_object_input_metadata_directive(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_object_lock_legal_hold_status(
            crate::http_serde::deser_header_copy_object_copy_object_input_object_lock_legal_hold_status(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_object_lock_mode(
            crate::http_serde::deser_header_copy_object_copy_object_input_object_lock_mode(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_object_lock_retain_until_date(
            crate::http_serde::deser_header_copy_object_copy_object_input_object_lock_retain_until_date(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_copy_object_copy_object_input_request_payer(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_sse_customer_algorithm(
            crate::http_serde::deser_header_copy_object_copy_object_input_sse_customer_algorithm(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_sse_customer_key(
            crate::http_serde::deser_header_copy_object_copy_object_input_sse_customer_key(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_sse_customer_key_md5(
            crate::http_serde::deser_header_copy_object_copy_object_input_sse_customer_key_md5(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_ssekms_encryption_context(
            crate::http_serde::deser_header_copy_object_copy_object_input_ssekms_encryption_context(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_ssekms_key_id(
            crate::http_serde::deser_header_copy_object_copy_object_input_ssekms_key_id(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_server_side_encryption(
            crate::http_serde::deser_header_copy_object_copy_object_input_server_side_encryption(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_storage_class(
            crate::http_serde::deser_header_copy_object_copy_object_input_storage_class(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_tagging(
            crate::http_serde::deser_header_copy_object_copy_object_input_tagging(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_tagging_directive(
            crate::http_serde::deser_header_copy_object_copy_object_input_tagging_directive(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_website_redirect_location(
            crate::http_serde::deser_header_copy_object_copy_object_input_website_redirect_location(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(crate::operation_deser::parse_str_copy_object_input_bucket(
            m0,
        )?);
        input = input.set_key(crate::operation_deser::parse_str_copy_object_input_key(m1)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_create_bucket_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::CreateBucketInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::create_bucket_input::Builder::default();
        input = input.set_acl(
            crate::http_serde::deser_header_create_bucket_create_bucket_input_acl(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_create_bucket_configuration(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_create_bucket_create_bucket_input_create_bucket_configuration(&bytes)?
                                        }
        );
        input = input.set_grant_full_control(
            crate::http_serde::deser_header_create_bucket_create_bucket_input_grant_full_control(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_grant_read(
            crate::http_serde::deser_header_create_bucket_create_bucket_input_grant_read(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_grant_read_acp(
            crate::http_serde::deser_header_create_bucket_create_bucket_input_grant_read_acp(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_grant_write(
            crate::http_serde::deser_header_create_bucket_create_bucket_input_grant_write(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_grant_write_acp(
            crate::http_serde::deser_header_create_bucket_create_bucket_input_grant_write_acp(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_object_lock_enabled_for_bucket(
            crate::http_serde::deser_header_create_bucket_create_bucket_input_object_lock_enabled_for_bucket(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_object_ownership(
            crate::http_serde::deser_header_create_bucket_create_bucket_input_object_ownership(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(crate::operation_deser::parse_str_create_bucket_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_create_multipart_upload_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::CreateMultipartUploadInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::create_multipart_upload_input::Builder::default();
        input = input.set_acl(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_acl(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_bucket_key_enabled(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_bucket_key_enabled(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_cache_control(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_cache_control(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_content_disposition(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_content_disposition(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_content_encoding(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_content_encoding(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_content_language(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_content_language(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_content_type(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_content_type(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_expires(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_expires(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_grant_full_control(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_grant_full_control(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_grant_read(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_grant_read(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_grant_read_acp(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_grant_read_acp(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_grant_write_acp(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_grant_write_acp(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_object_lock_legal_hold_status(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_object_lock_legal_hold_status(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_object_lock_mode(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_object_lock_mode(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_object_lock_retain_until_date(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_object_lock_retain_until_date(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_request_payer(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_sse_customer_algorithm(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_sse_customer_algorithm(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_sse_customer_key(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_sse_customer_key(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_sse_customer_key_md5(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_sse_customer_key_md5(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_ssekms_encryption_context(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_ssekms_encryption_context(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_ssekms_key_id(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_ssekms_key_id(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_server_side_encryption(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_server_side_encryption(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_storage_class(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_storage_class(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_tagging(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_tagging(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_website_redirect_location(
            crate::http_serde::deser_header_create_multipart_upload_create_multipart_upload_input_website_redirect_location(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_create_multipart_upload_input_bucket(m0)?,
        );
        input =
            input.set_key(crate::operation_deser::parse_str_create_multipart_upload_input_key(m1)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_delete_bucket_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::DeleteBucketInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::delete_bucket_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_delete_bucket_delete_bucket_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(crate::operation_deser::parse_str_delete_bucket_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_delete_bucket_analytics_configuration_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::DeleteBucketAnalyticsConfigurationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input =
            crate::input::delete_bucket_analytics_configuration_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_delete_bucket_analytics_configuration_delete_bucket_analytics_configuration_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_delete_bucket_analytics_configuration_input_bucket(
                m0,
            )?,
        );
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_id = false;
        for (k, v) in pairs {
            if !seen_id && k == "id" {
                input = input.set_id(
                    crate::operation_deser::parse_str_delete_bucket_analytics_configuration_input_id(&v)?
                );
                seen_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_delete_bucket_cors_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::DeleteBucketCorsInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::delete_bucket_cors_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_delete_bucket_cors_delete_bucket_cors_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_delete_bucket_cors_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_delete_bucket_encryption_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::DeleteBucketEncryptionInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::delete_bucket_encryption_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_delete_bucket_encryption_delete_bucket_encryption_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_delete_bucket_encryption_input_bucket(m0)?,
        );
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_delete_bucket_intelligent_tiering_configuration_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::DeleteBucketIntelligentTieringConfigurationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input =
            crate::input::delete_bucket_intelligent_tiering_configuration_input::Builder::default();
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_delete_bucket_intelligent_tiering_configuration_input_bucket(m0)?
        );
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_id = false;
        for (k, v) in pairs {
            if !seen_id && k == "id" {
                input = input.set_id(
                    crate::operation_deser::parse_str_delete_bucket_intelligent_tiering_configuration_input_id(&v)?
                );
                seen_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_delete_bucket_inventory_configuration_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::DeleteBucketInventoryConfigurationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input =
            crate::input::delete_bucket_inventory_configuration_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_delete_bucket_inventory_configuration_delete_bucket_inventory_configuration_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_delete_bucket_inventory_configuration_input_bucket(
                m0,
            )?,
        );
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_id = false;
        for (k, v) in pairs {
            if !seen_id && k == "id" {
                input = input.set_id(
                    crate::operation_deser::parse_str_delete_bucket_inventory_configuration_input_id(&v)?
                );
                seen_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_delete_bucket_lifecycle_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::DeleteBucketLifecycleInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::delete_bucket_lifecycle_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_delete_bucket_lifecycle_delete_bucket_lifecycle_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_delete_bucket_lifecycle_input_bucket(m0)?,
        );
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_delete_bucket_metrics_configuration_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::DeleteBucketMetricsConfigurationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::delete_bucket_metrics_configuration_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_delete_bucket_metrics_configuration_delete_bucket_metrics_configuration_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_delete_bucket_metrics_configuration_input_bucket(m0)?,
        );
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_id = false;
        for (k, v) in pairs {
            if !seen_id && k == "id" {
                input = input.set_id(
                    crate::operation_deser::parse_str_delete_bucket_metrics_configuration_input_id(
                        &v,
                    )?,
                );
                seen_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_delete_bucket_ownership_controls_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::DeleteBucketOwnershipControlsInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::delete_bucket_ownership_controls_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_delete_bucket_ownership_controls_delete_bucket_ownership_controls_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_delete_bucket_ownership_controls_input_bucket(m0)?,
        );
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_delete_bucket_policy_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::DeleteBucketPolicyInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::delete_bucket_policy_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_delete_bucket_policy_delete_bucket_policy_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_delete_bucket_policy_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_delete_bucket_replication_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::DeleteBucketReplicationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::delete_bucket_replication_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_delete_bucket_replication_delete_bucket_replication_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_delete_bucket_replication_input_bucket(m0)?,
        );
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_delete_bucket_tagging_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::DeleteBucketTaggingInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::delete_bucket_tagging_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_delete_bucket_tagging_delete_bucket_tagging_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_delete_bucket_tagging_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_delete_bucket_website_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::DeleteBucketWebsiteInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::delete_bucket_website_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_delete_bucket_website_delete_bucket_website_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_delete_bucket_website_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_delete_object_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::DeleteObjectInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::delete_object_input::Builder::default();
        input = input.set_bypass_governance_retention(
            crate::http_serde::deser_header_delete_object_delete_object_input_bypass_governance_retention(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_delete_object_delete_object_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_mfa(
            crate::http_serde::deser_header_delete_object_delete_object_input_mfa(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_delete_object_delete_object_input_request_payer(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(crate::operation_deser::parse_str_delete_object_input_bucket(m0)?);
        input = input.set_key(crate::operation_deser::parse_str_delete_object_input_key(
            m1,
        )?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_version_id = false;
        for (k, v) in pairs {
            if !seen_version_id && k == "versionId" {
                input = input.set_version_id(
                    crate::operation_deser::parse_str_delete_object_input_version_id(&v)?,
                );
                seen_version_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_delete_objects_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::DeleteObjectsInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::delete_objects_input::Builder::default();
        input = input.set_bypass_governance_retention(
            crate::http_serde::deser_header_delete_objects_delete_objects_input_bypass_governance_retention(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_delete({
            let body = request
                .take_body()
                .ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
            let bytes = hyper::body::to_bytes(body).await?;
            crate::http_serde::deser_payload_delete_objects_delete_objects_input_delete(&bytes)?
        });
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_delete_objects_delete_objects_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_mfa(
            crate::http_serde::deser_header_delete_objects_delete_objects_input_mfa(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_delete_objects_delete_objects_input_request_payer(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input =
            input.set_bucket(crate::operation_deser::parse_str_delete_objects_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_delete_object_tagging_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::DeleteObjectTaggingInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::delete_object_tagging_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_delete_object_tagging_delete_object_tagging_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_delete_object_tagging_input_bucket(m0)?);
        input =
            input.set_key(crate::operation_deser::parse_str_delete_object_tagging_input_key(m1)?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_version_id = false;
        for (k, v) in pairs {
            if !seen_version_id && k == "versionId" {
                input = input.set_version_id(
                    crate::operation_deser::parse_str_delete_object_tagging_input_version_id(&v)?,
                );
                seen_version_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_delete_public_access_block_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::DeletePublicAccessBlockInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::delete_public_access_block_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_delete_public_access_block_delete_public_access_block_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_delete_public_access_block_input_bucket(m0)?,
        );
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_bucket_accelerate_configuration_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetBucketAccelerateConfigurationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_bucket_accelerate_configuration_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_bucket_accelerate_configuration_get_bucket_accelerate_configuration_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_get_bucket_accelerate_configuration_input_bucket(m0)?,
        );
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_bucket_acl_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetBucketAclInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_bucket_acl_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_bucket_acl_get_bucket_acl_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input =
            input.set_bucket(crate::operation_deser::parse_str_get_bucket_acl_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_bucket_analytics_configuration_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetBucketAnalyticsConfigurationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_bucket_analytics_configuration_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_bucket_analytics_configuration_get_bucket_analytics_configuration_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_get_bucket_analytics_configuration_input_bucket(m0)?,
        );
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_id = false;
        for (k, v) in pairs {
            if !seen_id && k == "id" {
                input = input.set_id(
                    crate::operation_deser::parse_str_get_bucket_analytics_configuration_input_id(
                        &v,
                    )?,
                );
                seen_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_bucket_cors_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetBucketCorsInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_bucket_cors_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_bucket_cors_get_bucket_cors_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input =
            input.set_bucket(crate::operation_deser::parse_str_get_bucket_cors_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_bucket_encryption_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetBucketEncryptionInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_bucket_encryption_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_bucket_encryption_get_bucket_encryption_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_get_bucket_encryption_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_bucket_intelligent_tiering_configuration_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetBucketIntelligentTieringConfigurationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input =
            crate::input::get_bucket_intelligent_tiering_configuration_input::Builder::default();
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_get_bucket_intelligent_tiering_configuration_input_bucket(m0)?
        );
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_id = false;
        for (k, v) in pairs {
            if !seen_id && k == "id" {
                input = input.set_id(
                    crate::operation_deser::parse_str_get_bucket_intelligent_tiering_configuration_input_id(&v)?
                );
                seen_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_bucket_inventory_configuration_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetBucketInventoryConfigurationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_bucket_inventory_configuration_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_bucket_inventory_configuration_get_bucket_inventory_configuration_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_get_bucket_inventory_configuration_input_bucket(m0)?,
        );
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_id = false;
        for (k, v) in pairs {
            if !seen_id && k == "id" {
                input = input.set_id(
                    crate::operation_deser::parse_str_get_bucket_inventory_configuration_input_id(
                        &v,
                    )?,
                );
                seen_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_bucket_lifecycle_configuration_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetBucketLifecycleConfigurationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_bucket_lifecycle_configuration_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_bucket_lifecycle_configuration_get_bucket_lifecycle_configuration_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_get_bucket_lifecycle_configuration_input_bucket(m0)?,
        );
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_bucket_location_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetBucketLocationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_bucket_location_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_bucket_location_get_bucket_location_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_get_bucket_location_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_bucket_logging_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetBucketLoggingInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_bucket_logging_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_bucket_logging_get_bucket_logging_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_get_bucket_logging_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_bucket_metrics_configuration_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetBucketMetricsConfigurationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_bucket_metrics_configuration_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_bucket_metrics_configuration_get_bucket_metrics_configuration_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_get_bucket_metrics_configuration_input_bucket(m0)?,
        );
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_id = false;
        for (k, v) in pairs {
            if !seen_id && k == "id" {
                input = input.set_id(
                    crate::operation_deser::parse_str_get_bucket_metrics_configuration_input_id(
                        &v,
                    )?,
                );
                seen_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_bucket_notification_configuration_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetBucketNotificationConfigurationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input =
            crate::input::get_bucket_notification_configuration_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_bucket_notification_configuration_get_bucket_notification_configuration_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_get_bucket_notification_configuration_input_bucket(
                m0,
            )?,
        );
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_bucket_ownership_controls_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetBucketOwnershipControlsInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_bucket_ownership_controls_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_bucket_ownership_controls_get_bucket_ownership_controls_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_get_bucket_ownership_controls_input_bucket(m0)?,
        );
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_bucket_policy_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetBucketPolicyInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_bucket_policy_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_bucket_policy_get_bucket_policy_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input =
            input.set_bucket(crate::operation_deser::parse_str_get_bucket_policy_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_bucket_policy_status_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetBucketPolicyStatusInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_bucket_policy_status_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_bucket_policy_status_get_bucket_policy_status_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_get_bucket_policy_status_input_bucket(m0)?,
        );
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_bucket_replication_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetBucketReplicationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_bucket_replication_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_bucket_replication_get_bucket_replication_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_get_bucket_replication_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_bucket_request_payment_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetBucketRequestPaymentInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_bucket_request_payment_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_bucket_request_payment_get_bucket_request_payment_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_get_bucket_request_payment_input_bucket(m0)?,
        );
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_bucket_tagging_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetBucketTaggingInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_bucket_tagging_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_bucket_tagging_get_bucket_tagging_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_get_bucket_tagging_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_bucket_versioning_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetBucketVersioningInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_bucket_versioning_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_bucket_versioning_get_bucket_versioning_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_get_bucket_versioning_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_bucket_website_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetBucketWebsiteInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_bucket_website_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_bucket_website_get_bucket_website_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_get_bucket_website_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_object_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetObjectInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_object_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_object_get_object_input_expected_bucket_owner(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_if_match(
            crate::http_serde::deser_header_get_object_get_object_input_if_match(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_if_modified_since(
            crate::http_serde::deser_header_get_object_get_object_input_if_modified_since(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_if_none_match(
            crate::http_serde::deser_header_get_object_get_object_input_if_none_match(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_if_unmodified_since(
            crate::http_serde::deser_header_get_object_get_object_input_if_unmodified_since(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_range(
            crate::http_serde::deser_header_get_object_get_object_input_range(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_get_object_get_object_input_request_payer(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_sse_customer_algorithm(
            crate::http_serde::deser_header_get_object_get_object_input_sse_customer_algorithm(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_sse_customer_key(
            crate::http_serde::deser_header_get_object_get_object_input_sse_customer_key(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_sse_customer_key_md5(
            crate::http_serde::deser_header_get_object_get_object_input_sse_customer_key_md5(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(crate::operation_deser::parse_str_get_object_input_bucket(
            m0,
        )?);
        input = input.set_key(crate::operation_deser::parse_str_get_object_input_key(m1)?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_part_number = false;
        let mut seen_response_cache_control = false;
        let mut seen_response_content_disposition = false;
        let mut seen_response_content_encoding = false;
        let mut seen_response_content_language = false;
        let mut seen_response_content_type = false;
        let mut seen_response_expires = false;
        let mut seen_version_id = false;
        for (k, v) in pairs {
            if !seen_part_number && k == "partNumber" {
                input = input.set_part_number(
                    crate::operation_deser::parse_str_get_object_input_part_number(&v)?,
                );
                seen_part_number = true;
            }
            if !seen_response_cache_control && k == "response-cache-control" {
                input = input.set_response_cache_control(
                    crate::operation_deser::parse_str_get_object_input_response_cache_control(&v)?,
                );
                seen_response_cache_control = true;
            }
            if !seen_response_content_disposition && k == "response-content-disposition" {
                input = input.set_response_content_disposition(
                    crate::operation_deser::parse_str_get_object_input_response_content_disposition(&v)?
                );
                seen_response_content_disposition = true;
            }
            if !seen_response_content_encoding && k == "response-content-encoding" {
                input = input.set_response_content_encoding(
                    crate::operation_deser::parse_str_get_object_input_response_content_encoding(
                        &v,
                    )?,
                );
                seen_response_content_encoding = true;
            }
            if !seen_response_content_language && k == "response-content-language" {
                input = input.set_response_content_language(
                    crate::operation_deser::parse_str_get_object_input_response_content_language(
                        &v,
                    )?,
                );
                seen_response_content_language = true;
            }
            if !seen_response_content_type && k == "response-content-type" {
                input = input.set_response_content_type(
                    crate::operation_deser::parse_str_get_object_input_response_content_type(&v)?,
                );
                seen_response_content_type = true;
            }
            if !seen_response_expires && k == "response-expires" {
                input = input.set_response_expires(
                    crate::operation_deser::parse_str_get_object_input_response_expires(&v)?,
                );
                seen_response_expires = true;
            }
            if !seen_version_id && k == "versionId" {
                input = input.set_version_id(
                    crate::operation_deser::parse_str_get_object_input_version_id(&v)?,
                );
                seen_version_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_object_acl_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetObjectAclInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_object_acl_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_object_acl_get_object_acl_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_get_object_acl_get_object_acl_input_request_payer(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input =
            input.set_bucket(crate::operation_deser::parse_str_get_object_acl_input_bucket(m0)?);
        input = input.set_key(crate::operation_deser::parse_str_get_object_acl_input_key(
            m1,
        )?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_version_id = false;
        for (k, v) in pairs {
            if !seen_version_id && k == "versionId" {
                input = input.set_version_id(
                    crate::operation_deser::parse_str_get_object_acl_input_version_id(&v)?,
                );
                seen_version_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_object_legal_hold_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetObjectLegalHoldInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_object_legal_hold_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_object_legal_hold_get_object_legal_hold_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_get_object_legal_hold_get_object_legal_hold_input_request_payer(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_get_object_legal_hold_input_bucket(m0)?);
        input =
            input.set_key(crate::operation_deser::parse_str_get_object_legal_hold_input_key(m1)?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_version_id = false;
        for (k, v) in pairs {
            if !seen_version_id && k == "versionId" {
                input = input.set_version_id(
                    crate::operation_deser::parse_str_get_object_legal_hold_input_version_id(&v)?,
                );
                seen_version_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_object_lock_configuration_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetObjectLockConfigurationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_object_lock_configuration_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_object_lock_configuration_get_object_lock_configuration_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_get_object_lock_configuration_input_bucket(m0)?,
        );
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_object_retention_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetObjectRetentionInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_object_retention_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_object_retention_get_object_retention_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_get_object_retention_get_object_retention_input_request_payer(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_get_object_retention_input_bucket(m0)?);
        input =
            input.set_key(crate::operation_deser::parse_str_get_object_retention_input_key(m1)?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_version_id = false;
        for (k, v) in pairs {
            if !seen_version_id && k == "versionId" {
                input = input.set_version_id(
                    crate::operation_deser::parse_str_get_object_retention_input_version_id(&v)?,
                );
                seen_version_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_object_tagging_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetObjectTaggingInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_object_tagging_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_object_tagging_get_object_tagging_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_get_object_tagging_get_object_tagging_input_request_payer(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_get_object_tagging_input_bucket(m0)?);
        input = input.set_key(crate::operation_deser::parse_str_get_object_tagging_input_key(m1)?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_version_id = false;
        for (k, v) in pairs {
            if !seen_version_id && k == "versionId" {
                input = input.set_version_id(
                    crate::operation_deser::parse_str_get_object_tagging_input_version_id(&v)?,
                );
                seen_version_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_object_torrent_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetObjectTorrentInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_object_torrent_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_object_torrent_get_object_torrent_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_get_object_torrent_get_object_torrent_input_request_payer(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_get_object_torrent_input_bucket(m0)?);
        input = input.set_key(crate::operation_deser::parse_str_get_object_torrent_input_key(m1)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_get_public_access_block_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::GetPublicAccessBlockInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::get_public_access_block_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_get_public_access_block_get_public_access_block_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_get_public_access_block_input_bucket(m0)?,
        );
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_head_bucket_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::HeadBucketInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::head_bucket_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_head_bucket_head_bucket_input_expected_bucket_owner(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(crate::operation_deser::parse_str_head_bucket_input_bucket(
            m0,
        )?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_head_object_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::HeadObjectInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::head_object_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_head_object_head_object_input_expected_bucket_owner(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_if_match(
            crate::http_serde::deser_header_head_object_head_object_input_if_match(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_if_modified_since(
            crate::http_serde::deser_header_head_object_head_object_input_if_modified_since(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_if_none_match(
            crate::http_serde::deser_header_head_object_head_object_input_if_none_match(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_if_unmodified_since(
            crate::http_serde::deser_header_head_object_head_object_input_if_unmodified_since(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_range(
            crate::http_serde::deser_header_head_object_head_object_input_range(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_head_object_head_object_input_request_payer(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_sse_customer_algorithm(
            crate::http_serde::deser_header_head_object_head_object_input_sse_customer_algorithm(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_sse_customer_key(
            crate::http_serde::deser_header_head_object_head_object_input_sse_customer_key(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_sse_customer_key_md5(
            crate::http_serde::deser_header_head_object_head_object_input_sse_customer_key_md5(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(crate::operation_deser::parse_str_head_object_input_bucket(
            m0,
        )?);
        input = input.set_key(crate::operation_deser::parse_str_head_object_input_key(m1)?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_part_number = false;
        let mut seen_version_id = false;
        for (k, v) in pairs {
            if !seen_part_number && k == "partNumber" {
                input = input.set_part_number(
                    crate::operation_deser::parse_str_head_object_input_part_number(&v)?,
                );
                seen_part_number = true;
            }
            if !seen_version_id && k == "versionId" {
                input = input.set_version_id(
                    crate::operation_deser::parse_str_head_object_input_version_id(&v)?,
                );
                seen_version_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_list_bucket_analytics_configurations_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::ListBucketAnalyticsConfigurationsInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input =
            crate::input::list_bucket_analytics_configurations_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_list_bucket_analytics_configurations_list_bucket_analytics_configurations_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_list_bucket_analytics_configurations_input_bucket(
                m0,
            )?,
        );
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_continuation_token = false;
        for (k, v) in pairs {
            if !seen_continuation_token && k == "continuation-token" {
                input = input.set_continuation_token(
                    crate::operation_deser::parse_str_list_bucket_analytics_configurations_input_continuation_token(&v)?
                );
                seen_continuation_token = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_list_bucket_intelligent_tiering_configurations_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::ListBucketIntelligentTieringConfigurationsInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input =
            crate::input::list_bucket_intelligent_tiering_configurations_input::Builder::default();
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_list_bucket_intelligent_tiering_configurations_input_bucket(m0)?
        );
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_continuation_token = false;
        for (k, v) in pairs {
            if !seen_continuation_token && k == "continuation-token" {
                input = input.set_continuation_token(
                    crate::operation_deser::parse_str_list_bucket_intelligent_tiering_configurations_input_continuation_token(&v)?
                );
                seen_continuation_token = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_list_bucket_inventory_configurations_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::ListBucketInventoryConfigurationsInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input =
            crate::input::list_bucket_inventory_configurations_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_list_bucket_inventory_configurations_list_bucket_inventory_configurations_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_list_bucket_inventory_configurations_input_bucket(
                m0,
            )?,
        );
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_continuation_token = false;
        for (k, v) in pairs {
            if !seen_continuation_token && k == "continuation-token" {
                input = input.set_continuation_token(
                    crate::operation_deser::parse_str_list_bucket_inventory_configurations_input_continuation_token(&v)?
                );
                seen_continuation_token = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_list_bucket_metrics_configurations_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::ListBucketMetricsConfigurationsInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::list_bucket_metrics_configurations_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_list_bucket_metrics_configurations_list_bucket_metrics_configurations_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_list_bucket_metrics_configurations_input_bucket(m0)?,
        );
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_continuation_token = false;
        for (k, v) in pairs {
            if !seen_continuation_token && k == "continuation-token" {
                input = input.set_continuation_token(
                    crate::operation_deser::parse_str_list_bucket_metrics_configurations_input_continuation_token(&v)?
                );
                seen_continuation_token = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_list_buckets_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::ListBucketsInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::list_buckets_input::Builder::default();
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_list_multipart_uploads_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::ListMultipartUploadsInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::list_multipart_uploads_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_list_multipart_uploads_list_multipart_uploads_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_list_multipart_uploads_input_bucket(m0)?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_delimiter = false;
        let mut seen_encoding_type = false;
        let mut seen_key_marker = false;
        let mut seen_max_uploads = false;
        let mut seen_prefix = false;
        let mut seen_upload_id_marker = false;
        for (k, v) in pairs {
            if !seen_delimiter && k == "delimiter" {
                input = input.set_delimiter(
                    crate::operation_deser::parse_str_list_multipart_uploads_input_delimiter(&v)?,
                );
                seen_delimiter = true;
            }
            if !seen_encoding_type && k == "encoding-type" {
                input = input.set_encoding_type(
                    crate::operation_deser::parse_str_list_multipart_uploads_input_encoding_type(
                        &v,
                    )?,
                );
                seen_encoding_type = true;
            }
            if !seen_key_marker && k == "key-marker" {
                input = input.set_key_marker(
                    crate::operation_deser::parse_str_list_multipart_uploads_input_key_marker(&v)?,
                );
                seen_key_marker = true;
            }
            if !seen_max_uploads && k == "max-uploads" {
                input = input.set_max_uploads(
                    crate::operation_deser::parse_str_list_multipart_uploads_input_max_uploads(&v)?,
                );
                seen_max_uploads = true;
            }
            if !seen_prefix && k == "prefix" {
                input = input.set_prefix(
                    crate::operation_deser::parse_str_list_multipart_uploads_input_prefix(&v)?,
                );
                seen_prefix = true;
            }
            if !seen_upload_id_marker && k == "upload-id-marker" {
                input = input.set_upload_id_marker(
                    crate::operation_deser::parse_str_list_multipart_uploads_input_upload_id_marker(&v)?
                );
                seen_upload_id_marker = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_list_objects_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::ListObjectsInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::list_objects_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_list_objects_list_objects_input_expected_bucket_owner(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_list_objects_list_objects_input_request_payer(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(crate::operation_deser::parse_str_list_objects_input_bucket(
            m0,
        )?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_delimiter = false;
        let mut seen_encoding_type = false;
        let mut seen_marker = false;
        let mut seen_max_keys = false;
        let mut seen_prefix = false;
        for (k, v) in pairs {
            if !seen_delimiter && k == "delimiter" {
                input = input.set_delimiter(
                    crate::operation_deser::parse_str_list_objects_input_delimiter(&v)?,
                );
                seen_delimiter = true;
            }
            if !seen_encoding_type && k == "encoding-type" {
                input = input.set_encoding_type(
                    crate::operation_deser::parse_str_list_objects_input_encoding_type(&v)?,
                );
                seen_encoding_type = true;
            }
            if !seen_marker && k == "marker" {
                input = input.set_marker(
                    crate::operation_deser::parse_str_list_objects_input_marker(&v)?,
                );
                seen_marker = true;
            }
            if !seen_max_keys && k == "max-keys" {
                input = input.set_max_keys(
                    crate::operation_deser::parse_str_list_objects_input_max_keys(&v)?,
                );
                seen_max_keys = true;
            }
            if !seen_prefix && k == "prefix" {
                input = input.set_prefix(
                    crate::operation_deser::parse_str_list_objects_input_prefix(&v)?,
                );
                seen_prefix = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_list_objects_v2_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::ListObjectsV2Input,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::list_objects_v2_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_list_objects_v2_list_objects_v2_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_list_objects_v2_list_objects_v2_input_request_payer(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input =
            input.set_bucket(crate::operation_deser::parse_str_list_objects_v2_input_bucket(m0)?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_continuation_token = false;
        let mut seen_delimiter = false;
        let mut seen_encoding_type = false;
        let mut seen_fetch_owner = false;
        let mut seen_max_keys = false;
        let mut seen_prefix = false;
        let mut seen_start_after = false;
        for (k, v) in pairs {
            if !seen_continuation_token && k == "continuation-token" {
                input = input.set_continuation_token(
                    crate::operation_deser::parse_str_list_objects_v2_input_continuation_token(&v)?,
                );
                seen_continuation_token = true;
            }
            if !seen_delimiter && k == "delimiter" {
                input = input.set_delimiter(
                    crate::operation_deser::parse_str_list_objects_v2_input_delimiter(&v)?,
                );
                seen_delimiter = true;
            }
            if !seen_encoding_type && k == "encoding-type" {
                input = input.set_encoding_type(
                    crate::operation_deser::parse_str_list_objects_v2_input_encoding_type(&v)?,
                );
                seen_encoding_type = true;
            }
            if !seen_fetch_owner && k == "fetch-owner" {
                input = input.set_fetch_owner(
                    crate::operation_deser::parse_str_list_objects_v2_input_fetch_owner(&v)?,
                );
                seen_fetch_owner = true;
            }
            if !seen_max_keys && k == "max-keys" {
                input = input.set_max_keys(
                    crate::operation_deser::parse_str_list_objects_v2_input_max_keys(&v)?,
                );
                seen_max_keys = true;
            }
            if !seen_prefix && k == "prefix" {
                input = input.set_prefix(
                    crate::operation_deser::parse_str_list_objects_v2_input_prefix(&v)?,
                );
                seen_prefix = true;
            }
            if !seen_start_after && k == "start-after" {
                input = input.set_start_after(
                    crate::operation_deser::parse_str_list_objects_v2_input_start_after(&v)?,
                );
                seen_start_after = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_list_object_versions_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::ListObjectVersionsInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::list_object_versions_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_list_object_versions_list_object_versions_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_list_object_versions_input_bucket(m0)?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_delimiter = false;
        let mut seen_encoding_type = false;
        let mut seen_key_marker = false;
        let mut seen_max_keys = false;
        let mut seen_prefix = false;
        let mut seen_version_id_marker = false;
        for (k, v) in pairs {
            if !seen_delimiter && k == "delimiter" {
                input = input.set_delimiter(
                    crate::operation_deser::parse_str_list_object_versions_input_delimiter(&v)?,
                );
                seen_delimiter = true;
            }
            if !seen_encoding_type && k == "encoding-type" {
                input = input.set_encoding_type(
                    crate::operation_deser::parse_str_list_object_versions_input_encoding_type(&v)?,
                );
                seen_encoding_type = true;
            }
            if !seen_key_marker && k == "key-marker" {
                input = input.set_key_marker(
                    crate::operation_deser::parse_str_list_object_versions_input_key_marker(&v)?,
                );
                seen_key_marker = true;
            }
            if !seen_max_keys && k == "max-keys" {
                input = input.set_max_keys(
                    crate::operation_deser::parse_str_list_object_versions_input_max_keys(&v)?,
                );
                seen_max_keys = true;
            }
            if !seen_prefix && k == "prefix" {
                input = input.set_prefix(
                    crate::operation_deser::parse_str_list_object_versions_input_prefix(&v)?,
                );
                seen_prefix = true;
            }
            if !seen_version_id_marker && k == "version-id-marker" {
                input = input.set_version_id_marker(
                    crate::operation_deser::parse_str_list_object_versions_input_version_id_marker(
                        &v,
                    )?,
                );
                seen_version_id_marker = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_list_parts_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::ListPartsInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::list_parts_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_list_parts_list_parts_input_expected_bucket_owner(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_list_parts_list_parts_input_request_payer(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(crate::operation_deser::parse_str_list_parts_input_bucket(
            m0,
        )?);
        input = input.set_key(crate::operation_deser::parse_str_list_parts_input_key(m1)?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_max_parts = false;
        let mut seen_part_number_marker = false;
        let mut seen_upload_id = false;
        for (k, v) in pairs {
            if !seen_max_parts && k == "max-parts" {
                input = input.set_max_parts(
                    crate::operation_deser::parse_str_list_parts_input_max_parts(&v)?,
                );
                seen_max_parts = true;
            }
            if !seen_part_number_marker && k == "part-number-marker" {
                input = input.set_part_number_marker(
                    crate::operation_deser::parse_str_list_parts_input_part_number_marker(&v)?,
                );
                seen_part_number_marker = true;
            }
            if !seen_upload_id && k == "uploadId" {
                input = input.set_upload_id(
                    crate::operation_deser::parse_str_list_parts_input_upload_id(&v)?,
                );
                seen_upload_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_bucket_accelerate_configuration_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutBucketAccelerateConfigurationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_bucket_accelerate_configuration_input::Builder::default();
        input = input.set_accelerate_configuration(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_put_bucket_accelerate_configuration_put_bucket_accelerate_configuration_input_accelerate_configuration(&bytes)?
                                        }
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_bucket_accelerate_configuration_put_bucket_accelerate_configuration_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_put_bucket_accelerate_configuration_input_bucket(m0)?,
        );
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_bucket_acl_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutBucketAclInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_bucket_acl_input::Builder::default();
        input = input.set_acl(
            crate::http_serde::deser_header_put_bucket_acl_put_bucket_acl_input_acl(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_access_control_policy(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_put_bucket_acl_put_bucket_acl_input_access_control_policy(&bytes)?
                                        }
        );
        input = input.set_content_md5(
            crate::http_serde::deser_header_put_bucket_acl_put_bucket_acl_input_content_md5(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_bucket_acl_put_bucket_acl_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_grant_full_control(
            crate::http_serde::deser_header_put_bucket_acl_put_bucket_acl_input_grant_full_control(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_grant_read(
            crate::http_serde::deser_header_put_bucket_acl_put_bucket_acl_input_grant_read(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_grant_read_acp(
            crate::http_serde::deser_header_put_bucket_acl_put_bucket_acl_input_grant_read_acp(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_grant_write(
            crate::http_serde::deser_header_put_bucket_acl_put_bucket_acl_input_grant_write(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_grant_write_acp(
            crate::http_serde::deser_header_put_bucket_acl_put_bucket_acl_input_grant_write_acp(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input =
            input.set_bucket(crate::operation_deser::parse_str_put_bucket_acl_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_bucket_analytics_configuration_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutBucketAnalyticsConfigurationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_bucket_analytics_configuration_input::Builder::default();
        input = input.set_analytics_configuration(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_put_bucket_analytics_configuration_put_bucket_analytics_configuration_input_analytics_configuration(&bytes)?
                                        }
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_bucket_analytics_configuration_put_bucket_analytics_configuration_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_put_bucket_analytics_configuration_input_bucket(m0)?,
        );
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_id = false;
        for (k, v) in pairs {
            if !seen_id && k == "id" {
                input = input.set_id(
                    crate::operation_deser::parse_str_put_bucket_analytics_configuration_input_id(
                        &v,
                    )?,
                );
                seen_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_bucket_cors_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutBucketCorsInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_bucket_cors_input::Builder::default();
        input = input.set_cors_configuration(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_put_bucket_cors_put_bucket_cors_input_cors_configuration(&bytes)?
                                        }
        );
        input = input.set_content_md5(
            crate::http_serde::deser_header_put_bucket_cors_put_bucket_cors_input_content_md5(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_bucket_cors_put_bucket_cors_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input =
            input.set_bucket(crate::operation_deser::parse_str_put_bucket_cors_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_bucket_encryption_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutBucketEncryptionInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_bucket_encryption_input::Builder::default();
        input = input.set_content_md5(
            crate::http_serde::deser_header_put_bucket_encryption_put_bucket_encryption_input_content_md5(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_bucket_encryption_put_bucket_encryption_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_server_side_encryption_configuration(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_put_bucket_encryption_put_bucket_encryption_input_server_side_encryption_configuration(&bytes)?
                                        }
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_put_bucket_encryption_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_bucket_intelligent_tiering_configuration_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutBucketIntelligentTieringConfigurationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input =
            crate::input::put_bucket_intelligent_tiering_configuration_input::Builder::default();
        input = input.set_intelligent_tiering_configuration(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_put_bucket_intelligent_tiering_configuration_put_bucket_intelligent_tiering_configuration_input_intelligent_tiering_configuration(&bytes)?
                                        }
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_put_bucket_intelligent_tiering_configuration_input_bucket(m0)?
        );
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_id = false;
        for (k, v) in pairs {
            if !seen_id && k == "id" {
                input = input.set_id(
                    crate::operation_deser::parse_str_put_bucket_intelligent_tiering_configuration_input_id(&v)?
                );
                seen_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_bucket_inventory_configuration_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutBucketInventoryConfigurationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_bucket_inventory_configuration_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_bucket_inventory_configuration_put_bucket_inventory_configuration_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_inventory_configuration(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_put_bucket_inventory_configuration_put_bucket_inventory_configuration_input_inventory_configuration(&bytes)?
                                        }
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_put_bucket_inventory_configuration_input_bucket(m0)?,
        );
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_id = false;
        for (k, v) in pairs {
            if !seen_id && k == "id" {
                input = input.set_id(
                    crate::operation_deser::parse_str_put_bucket_inventory_configuration_input_id(
                        &v,
                    )?,
                );
                seen_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_bucket_lifecycle_configuration_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutBucketLifecycleConfigurationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_bucket_lifecycle_configuration_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_bucket_lifecycle_configuration_put_bucket_lifecycle_configuration_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_lifecycle_configuration(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_put_bucket_lifecycle_configuration_put_bucket_lifecycle_configuration_input_lifecycle_configuration(&bytes)?
                                        }
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_put_bucket_lifecycle_configuration_input_bucket(m0)?,
        );
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_bucket_logging_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutBucketLoggingInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_bucket_logging_input::Builder::default();
        input = input.set_bucket_logging_status(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_put_bucket_logging_put_bucket_logging_input_bucket_logging_status(&bytes)?
                                        }
        );
        input = input.set_content_md5(
            crate::http_serde::deser_header_put_bucket_logging_put_bucket_logging_input_content_md5(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_bucket_logging_put_bucket_logging_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_put_bucket_logging_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_bucket_metrics_configuration_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutBucketMetricsConfigurationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_bucket_metrics_configuration_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_bucket_metrics_configuration_put_bucket_metrics_configuration_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_metrics_configuration(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_put_bucket_metrics_configuration_put_bucket_metrics_configuration_input_metrics_configuration(&bytes)?
                                        }
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_put_bucket_metrics_configuration_input_bucket(m0)?,
        );
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_id = false;
        for (k, v) in pairs {
            if !seen_id && k == "id" {
                input = input.set_id(
                    crate::operation_deser::parse_str_put_bucket_metrics_configuration_input_id(
                        &v,
                    )?,
                );
                seen_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_bucket_notification_configuration_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutBucketNotificationConfigurationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input =
            crate::input::put_bucket_notification_configuration_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_bucket_notification_configuration_put_bucket_notification_configuration_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_notification_configuration(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_put_bucket_notification_configuration_put_bucket_notification_configuration_input_notification_configuration(&bytes)?
                                        }
        );
        input = input.set_skip_destination_validation(
            crate::http_serde::deser_header_put_bucket_notification_configuration_put_bucket_notification_configuration_input_skip_destination_validation(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_put_bucket_notification_configuration_input_bucket(
                m0,
            )?,
        );
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_bucket_ownership_controls_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutBucketOwnershipControlsInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_bucket_ownership_controls_input::Builder::default();
        input = input.set_content_md5(
            crate::http_serde::deser_header_put_bucket_ownership_controls_put_bucket_ownership_controls_input_content_md5(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_bucket_ownership_controls_put_bucket_ownership_controls_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_ownership_controls(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_put_bucket_ownership_controls_put_bucket_ownership_controls_input_ownership_controls(&bytes)?
                                        }
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_put_bucket_ownership_controls_input_bucket(m0)?,
        );
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_bucket_policy_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutBucketPolicyInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_bucket_policy_input::Builder::default();
        input = input.set_confirm_remove_self_bucket_access(
            crate::http_serde::deser_header_put_bucket_policy_put_bucket_policy_input_confirm_remove_self_bucket_access(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_content_md5(
            crate::http_serde::deser_header_put_bucket_policy_put_bucket_policy_input_content_md5(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_bucket_policy_put_bucket_policy_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_policy({
            let body = request
                .take_body()
                .ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
            let bytes = hyper::body::to_bytes(body).await?;
            crate::http_serde::deser_payload_put_bucket_policy_put_bucket_policy_input_policy(
                &bytes,
            )?
        });
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input =
            input.set_bucket(crate::operation_deser::parse_str_put_bucket_policy_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_bucket_replication_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutBucketReplicationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_bucket_replication_input::Builder::default();
        input = input.set_content_md5(
            crate::http_serde::deser_header_put_bucket_replication_put_bucket_replication_input_content_md5(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_bucket_replication_put_bucket_replication_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_replication_configuration(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_put_bucket_replication_put_bucket_replication_input_replication_configuration(&bytes)?
                                        }
        );
        input = input.set_token(
            crate::http_serde::deser_header_put_bucket_replication_put_bucket_replication_input_token(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_put_bucket_replication_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_bucket_request_payment_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutBucketRequestPaymentInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_bucket_request_payment_input::Builder::default();
        input = input.set_content_md5(
            crate::http_serde::deser_header_put_bucket_request_payment_put_bucket_request_payment_input_content_md5(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_bucket_request_payment_put_bucket_request_payment_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_request_payment_configuration(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_put_bucket_request_payment_put_bucket_request_payment_input_request_payment_configuration(&bytes)?
                                        }
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_put_bucket_request_payment_input_bucket(m0)?,
        );
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_bucket_tagging_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutBucketTaggingInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_bucket_tagging_input::Builder::default();
        input = input.set_content_md5(
            crate::http_serde::deser_header_put_bucket_tagging_put_bucket_tagging_input_content_md5(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_bucket_tagging_put_bucket_tagging_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_tagging({
            let body = request
                .take_body()
                .ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
            let bytes = hyper::body::to_bytes(body).await?;
            crate::http_serde::deser_payload_put_bucket_tagging_put_bucket_tagging_input_tagging(
                &bytes,
            )?
        });
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_put_bucket_tagging_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_bucket_versioning_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutBucketVersioningInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_bucket_versioning_input::Builder::default();
        input = input.set_content_md5(
            crate::http_serde::deser_header_put_bucket_versioning_put_bucket_versioning_input_content_md5(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_bucket_versioning_put_bucket_versioning_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_mfa(
            crate::http_serde::deser_header_put_bucket_versioning_put_bucket_versioning_input_mfa(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_versioning_configuration(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_put_bucket_versioning_put_bucket_versioning_input_versioning_configuration(&bytes)?
                                        }
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_put_bucket_versioning_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_bucket_website_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutBucketWebsiteInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_bucket_website_input::Builder::default();
        input = input.set_content_md5(
            crate::http_serde::deser_header_put_bucket_website_put_bucket_website_input_content_md5(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_bucket_website_put_bucket_website_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_website_configuration(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_put_bucket_website_put_bucket_website_input_website_configuration(&bytes)?
                                        }
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_put_bucket_website_input_bucket(m0)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_object_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutObjectInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B: Into<aws_smithy_http_server::ByteStream>,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_object_input::Builder::default();
        let body = request
            .take_body()
            .ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
        input = input.set_body(Some(body.into()));
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(crate::operation_deser::parse_str_put_object_input_bucket(
            m0,
        )?);
        input = input.set_key(crate::operation_deser::parse_str_put_object_input_key(m1)?);
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_object_acl_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutObjectAclInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_object_acl_input::Builder::default();
        input = input.set_acl(
            crate::http_serde::deser_header_put_object_acl_put_object_acl_input_acl(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_access_control_policy(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_put_object_acl_put_object_acl_input_access_control_policy(&bytes)?
                                        }
        );
        input = input.set_content_md5(
            crate::http_serde::deser_header_put_object_acl_put_object_acl_input_content_md5(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_object_acl_put_object_acl_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_grant_full_control(
            crate::http_serde::deser_header_put_object_acl_put_object_acl_input_grant_full_control(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_grant_read(
            crate::http_serde::deser_header_put_object_acl_put_object_acl_input_grant_read(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_grant_read_acp(
            crate::http_serde::deser_header_put_object_acl_put_object_acl_input_grant_read_acp(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_grant_write(
            crate::http_serde::deser_header_put_object_acl_put_object_acl_input_grant_write(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_grant_write_acp(
            crate::http_serde::deser_header_put_object_acl_put_object_acl_input_grant_write_acp(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_put_object_acl_put_object_acl_input_request_payer(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input =
            input.set_bucket(crate::operation_deser::parse_str_put_object_acl_input_bucket(m0)?);
        input = input.set_key(crate::operation_deser::parse_str_put_object_acl_input_key(
            m1,
        )?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_version_id = false;
        for (k, v) in pairs {
            if !seen_version_id && k == "versionId" {
                input = input.set_version_id(
                    crate::operation_deser::parse_str_put_object_acl_input_version_id(&v)?,
                );
                seen_version_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_object_legal_hold_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutObjectLegalHoldInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_object_legal_hold_input::Builder::default();
        input = input.set_content_md5(
            crate::http_serde::deser_header_put_object_legal_hold_put_object_legal_hold_input_content_md5(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_object_legal_hold_put_object_legal_hold_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_legal_hold(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_put_object_legal_hold_put_object_legal_hold_input_legal_hold(&bytes)?
                                        }
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_put_object_legal_hold_put_object_legal_hold_input_request_payer(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_put_object_legal_hold_input_bucket(m0)?);
        input =
            input.set_key(crate::operation_deser::parse_str_put_object_legal_hold_input_key(m1)?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_version_id = false;
        for (k, v) in pairs {
            if !seen_version_id && k == "versionId" {
                input = input.set_version_id(
                    crate::operation_deser::parse_str_put_object_legal_hold_input_version_id(&v)?,
                );
                seen_version_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_object_lock_configuration_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutObjectLockConfigurationInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_object_lock_configuration_input::Builder::default();
        input = input.set_content_md5(
            crate::http_serde::deser_header_put_object_lock_configuration_put_object_lock_configuration_input_content_md5(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_object_lock_configuration_put_object_lock_configuration_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_object_lock_configuration(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_put_object_lock_configuration_put_object_lock_configuration_input_object_lock_configuration(&bytes)?
                                        }
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_put_object_lock_configuration_put_object_lock_configuration_input_request_payer(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_token(
            crate::http_serde::deser_header_put_object_lock_configuration_put_object_lock_configuration_input_token(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_put_object_lock_configuration_input_bucket(m0)?,
        );
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_object_retention_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutObjectRetentionInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_object_retention_input::Builder::default();
        input = input.set_bypass_governance_retention(
            crate::http_serde::deser_header_put_object_retention_put_object_retention_input_bypass_governance_retention(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_content_md5(
            crate::http_serde::deser_header_put_object_retention_put_object_retention_input_content_md5(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_object_retention_put_object_retention_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_put_object_retention_put_object_retention_input_request_payer(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_retention(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_put_object_retention_put_object_retention_input_retention(&bytes)?
                                        }
        );
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_put_object_retention_input_bucket(m0)?);
        input =
            input.set_key(crate::operation_deser::parse_str_put_object_retention_input_key(m1)?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_version_id = false;
        for (k, v) in pairs {
            if !seen_version_id && k == "versionId" {
                input = input.set_version_id(
                    crate::operation_deser::parse_str_put_object_retention_input_version_id(&v)?,
                );
                seen_version_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_object_tagging_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutObjectTaggingInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_object_tagging_input::Builder::default();
        input = input.set_content_md5(
            crate::http_serde::deser_header_put_object_tagging_put_object_tagging_input_content_md5(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_object_tagging_put_object_tagging_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_put_object_tagging_put_object_tagging_input_request_payer(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_tagging({
            let body = request
                .take_body()
                .ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
            let bytes = hyper::body::to_bytes(body).await?;
            crate::http_serde::deser_payload_put_object_tagging_put_object_tagging_input_tagging(
                &bytes,
            )?
        });
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input = input
            .set_bucket(crate::operation_deser::parse_str_put_object_tagging_input_bucket(m0)?);
        input = input.set_key(crate::operation_deser::parse_str_put_object_tagging_input_key(m1)?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_version_id = false;
        for (k, v) in pairs {
            if !seen_version_id && k == "versionId" {
                input = input.set_version_id(
                    crate::operation_deser::parse_str_put_object_tagging_input_version_id(&v)?,
                );
                seen_version_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_put_public_access_block_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::PutPublicAccessBlockInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::put_public_access_block_input::Builder::default();
        input = input.set_content_md5(
            crate::http_serde::deser_header_put_public_access_block_put_public_access_block_input_content_md5(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_put_public_access_block_put_public_access_block_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_public_access_block_configuration(
            {
                                            let body = request.take_body().ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
                                            let bytes = hyper::body::to_bytes(body).await?;
                                            crate::http_serde::deser_payload_put_public_access_block_put_public_access_block_input_public_access_block_configuration(&bytes)?
                                        }
        );
        let input_string = request.uri().path();
        let (input_string, m0) = nom::sequence::preceded(
            nom::bytes::complete::tag("/"),
            nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                nom::bytes::complete::take_until("/"),
                nom::combinator::rest,
            )),
        )(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(
            crate::operation_deser::parse_str_put_public_access_block_input_bucket(m0)?,
        );
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_restore_object_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::RestoreObjectInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::restore_object_input::Builder::default();
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_restore_object_restore_object_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_restore_object_restore_object_input_request_payer(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_restore_request({
            let body = request
                .take_body()
                .ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
            let bytes = hyper::body::to_bytes(body).await?;
            crate::http_serde::deser_payload_restore_object_restore_object_input_restore_request(
                &bytes,
            )?
        });
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input =
            input.set_bucket(crate::operation_deser::parse_str_restore_object_input_bucket(m0)?);
        input = input.set_key(crate::operation_deser::parse_str_restore_object_input_key(
            m1,
        )?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_version_id = false;
        for (k, v) in pairs {
            if !seen_version_id && k == "versionId" {
                input = input.set_version_id(
                    crate::operation_deser::parse_str_restore_object_input_version_id(&v)?,
                );
                seen_version_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_upload_part_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::UploadPartInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B: Into<aws_smithy_http_server::ByteStream>,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::upload_part_input::Builder::default();
        let body = request
            .take_body()
            .ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
        input = input.set_body(Some(body.into()));
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input = input.set_bucket(crate::operation_deser::parse_str_upload_part_input_bucket(
            m0,
        )?);
        input = input.set_key(crate::operation_deser::parse_str_upload_part_input_key(m1)?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_part_number = false;
        let mut seen_upload_id = false;
        for (k, v) in pairs {
            if !seen_part_number && k == "partNumber" {
                input = input.set_part_number(
                    crate::operation_deser::parse_str_upload_part_input_part_number(&v)?,
                );
                seen_part_number = true;
            }
            if !seen_upload_id && k == "uploadId" {
                input = input.set_upload_id(
                    crate::operation_deser::parse_str_upload_part_input_upload_id(&v)?,
                );
                seen_upload_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_upload_part_copy_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::UploadPartCopyInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::upload_part_copy_input::Builder::default();
        input = input.set_copy_source(
            crate::http_serde::deser_header_upload_part_copy_upload_part_copy_input_copy_source(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_copy_source_if_match(
            crate::http_serde::deser_header_upload_part_copy_upload_part_copy_input_copy_source_if_match(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_copy_source_if_modified_since(
            crate::http_serde::deser_header_upload_part_copy_upload_part_copy_input_copy_source_if_modified_since(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_copy_source_if_none_match(
            crate::http_serde::deser_header_upload_part_copy_upload_part_copy_input_copy_source_if_none_match(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_copy_source_if_unmodified_since(
            crate::http_serde::deser_header_upload_part_copy_upload_part_copy_input_copy_source_if_unmodified_since(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_copy_source_range(
            crate::http_serde::deser_header_upload_part_copy_upload_part_copy_input_copy_source_range(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_copy_source_sse_customer_algorithm(
            crate::http_serde::deser_header_upload_part_copy_upload_part_copy_input_copy_source_sse_customer_algorithm(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_copy_source_sse_customer_key(
            crate::http_serde::deser_header_upload_part_copy_upload_part_copy_input_copy_source_sse_customer_key(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_copy_source_sse_customer_key_md5(
            crate::http_serde::deser_header_upload_part_copy_upload_part_copy_input_copy_source_sse_customer_key_md5(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_expected_bucket_owner(
            crate::http_serde::deser_header_upload_part_copy_upload_part_copy_input_expected_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_expected_source_bucket_owner(
            crate::http_serde::deser_header_upload_part_copy_upload_part_copy_input_expected_source_bucket_owner(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_request_payer(
            crate::http_serde::deser_header_upload_part_copy_upload_part_copy_input_request_payer(
                request
                    .headers()
                    .ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?,
            )?,
        );
        input = input.set_sse_customer_algorithm(
            crate::http_serde::deser_header_upload_part_copy_upload_part_copy_input_sse_customer_algorithm(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_sse_customer_key(
            crate::http_serde::deser_header_upload_part_copy_upload_part_copy_input_sse_customer_key(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        input = input.set_sse_customer_key_md5(
            crate::http_serde::deser_header_upload_part_copy_upload_part_copy_input_sse_customer_key_md5(request.headers().ok_or(aws_smithy_http_server::rejection::HeadersAlreadyExtracted)?)?
        );
        let input_string = request.uri().path();
        let (input_string, (m0, m1)) = nom::sequence::tuple::<_, _, nom::error::Error<&str>, _>((
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::branch::alt::<_, _, nom::error::Error<&str>, _>((
                    nom::bytes::complete::take_until("/"),
                    nom::combinator::rest,
                )),
            ),
            nom::sequence::preceded(
                nom::bytes::complete::tag("/"),
                nom::combinator::rest::<_, nom::error::Error<&str>>,
            ),
        ))(input_string)?;
        debug_assert_eq!("", input_string);
        input =
            input.set_bucket(crate::operation_deser::parse_str_upload_part_copy_input_bucket(m0)?);
        input = input.set_key(crate::operation_deser::parse_str_upload_part_copy_input_key(m1)?);
        let query_string = request.uri().query().unwrap_or("");
        let pairs = serde_urlencoded::from_str::<
            Vec<(std::borrow::Cow<'_, str>, std::borrow::Cow<'_, str>)>,
        >(query_string)?;
        let mut seen_part_number = false;
        let mut seen_upload_id = false;
        for (k, v) in pairs {
            if !seen_part_number && k == "partNumber" {
                input = input.set_part_number(
                    crate::operation_deser::parse_str_upload_part_copy_input_part_number(&v)?,
                );
                seen_part_number = true;
            }
            if !seen_upload_id && k == "uploadId" {
                input = input.set_upload_id(
                    crate::operation_deser::parse_str_upload_part_copy_input_upload_id(&v)?,
                );
                seen_upload_id = true;
            }
        }
        input.build()?
    })
}

#[allow(clippy::unnecessary_wraps)]
pub async fn parse_write_get_object_response_request<B>(
    #[allow(unused_variables)] request: &mut axum_core::extract::RequestParts<B>,
) -> std::result::Result<
    crate::input::WriteGetObjectResponseInput,
    aws_smithy_http_server::rejection::SmithyRejection,
>
where
    B: aws_smithy_http_server::HttpBody + Send,
    B: Into<aws_smithy_http_server::ByteStream>,
    B::Data: Send,
    B::Error: Into<aws_smithy_http_server::BoxError>,
    aws_smithy_http_server::rejection::SmithyRejection:
        From<<B as aws_smithy_http_server::HttpBody>::Error>,
{
    Ok({
        #[allow(unused_mut)]
        let mut input = crate::input::write_get_object_response_input::Builder::default();
        let body = request
            .take_body()
            .ok_or(aws_smithy_http_server::rejection::BodyAlreadyExtracted)?;
        input = input.set_body(Some(body.into()));
        input.build()?
    })
}

pub fn parse_str_abort_multipart_upload_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_abort_multipart_upload_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_abort_multipart_upload_input_upload_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_complete_multipart_upload_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_complete_multipart_upload_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_complete_multipart_upload_input_upload_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_copy_object_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_copy_object_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_create_bucket_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_create_multipart_upload_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_create_multipart_upload_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_bucket_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_bucket_analytics_configuration_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_bucket_analytics_configuration_input_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_bucket_cors_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_bucket_encryption_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_bucket_intelligent_tiering_configuration_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_bucket_intelligent_tiering_configuration_input_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_bucket_inventory_configuration_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_bucket_inventory_configuration_input_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_bucket_lifecycle_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_bucket_metrics_configuration_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_bucket_metrics_configuration_input_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_bucket_ownership_controls_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_bucket_policy_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_bucket_replication_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_bucket_tagging_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_bucket_website_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_object_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_object_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_object_input_version_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_objects_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_object_tagging_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_object_tagging_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_object_tagging_input_version_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_delete_public_access_block_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_accelerate_configuration_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_acl_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_analytics_configuration_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_analytics_configuration_input_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_cors_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_encryption_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_intelligent_tiering_configuration_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_intelligent_tiering_configuration_input_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_inventory_configuration_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_inventory_configuration_input_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_lifecycle_configuration_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_location_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_logging_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_metrics_configuration_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_metrics_configuration_input_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_notification_configuration_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_ownership_controls_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_policy_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_policy_status_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_replication_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_request_payment_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_tagging_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_versioning_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_bucket_website_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_input_part_number(
    value: &str,
) -> std::result::Result<std::option::Option<i32>, aws_smithy_http_server::rejection::SmithyRejection>
{
    let value = std::str::FromStr::from_str(value)?;
    Ok(Some(value))
}

pub fn parse_str_get_object_input_response_cache_control(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_input_response_content_disposition(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_input_response_content_encoding(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_input_response_content_language(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_input_response_content_type(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_input_response_expires(
    value: &str,
) -> std::result::Result<
    std::option::Option<aws_smithy_types::DateTime>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = percent_encoding::percent_decode_str(value).decode_utf8()?;
    let value = aws_smithy_types::DateTime::from_str(
        &value,
        aws_smithy_types::date_time::Format::HttpDate,
    )?;
    Ok(Some(value))
}

pub fn parse_str_get_object_input_version_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_acl_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_acl_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_acl_input_version_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_legal_hold_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_legal_hold_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_legal_hold_input_version_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_lock_configuration_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_retention_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_retention_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_retention_input_version_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_tagging_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_tagging_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_tagging_input_version_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_torrent_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_object_torrent_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_get_public_access_block_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_head_bucket_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_head_object_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_head_object_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_head_object_input_part_number(
    value: &str,
) -> std::result::Result<std::option::Option<i32>, aws_smithy_http_server::rejection::SmithyRejection>
{
    let value = std::str::FromStr::from_str(value)?;
    Ok(Some(value))
}

pub fn parse_str_head_object_input_version_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_bucket_analytics_configurations_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_bucket_analytics_configurations_input_continuation_token(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_bucket_intelligent_tiering_configurations_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_bucket_intelligent_tiering_configurations_input_continuation_token(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_bucket_inventory_configurations_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_bucket_inventory_configurations_input_continuation_token(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_bucket_metrics_configurations_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_bucket_metrics_configurations_input_continuation_token(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_multipart_uploads_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_multipart_uploads_input_delimiter(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_multipart_uploads_input_encoding_type(
    value: &str,
) -> std::result::Result<
    std::option::Option<crate::model::EncodingType>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_multipart_uploads_input_key_marker(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_multipart_uploads_input_max_uploads(
    value: &str,
) -> std::result::Result<std::option::Option<i32>, aws_smithy_http_server::rejection::SmithyRejection>
{
    let value = std::str::FromStr::from_str(value)?;
    Ok(Some(value))
}

pub fn parse_str_list_multipart_uploads_input_prefix(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_multipart_uploads_input_upload_id_marker(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_objects_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_objects_input_delimiter(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_objects_input_encoding_type(
    value: &str,
) -> std::result::Result<
    std::option::Option<crate::model::EncodingType>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_objects_input_marker(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_objects_input_max_keys(
    value: &str,
) -> std::result::Result<std::option::Option<i32>, aws_smithy_http_server::rejection::SmithyRejection>
{
    let value = std::str::FromStr::from_str(value)?;
    Ok(Some(value))
}

pub fn parse_str_list_objects_input_prefix(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_objects_v2_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_objects_v2_input_continuation_token(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_objects_v2_input_delimiter(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_objects_v2_input_encoding_type(
    value: &str,
) -> std::result::Result<
    std::option::Option<crate::model::EncodingType>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_objects_v2_input_fetch_owner(
    value: &str,
) -> std::result::Result<
    std::option::Option<bool>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = std::str::FromStr::from_str(value)?;
    Ok(Some(value))
}

pub fn parse_str_list_objects_v2_input_max_keys(
    value: &str,
) -> std::result::Result<std::option::Option<i32>, aws_smithy_http_server::rejection::SmithyRejection>
{
    let value = std::str::FromStr::from_str(value)?;
    Ok(Some(value))
}

pub fn parse_str_list_objects_v2_input_prefix(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_objects_v2_input_start_after(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_object_versions_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_object_versions_input_delimiter(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_object_versions_input_encoding_type(
    value: &str,
) -> std::result::Result<
    std::option::Option<crate::model::EncodingType>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_object_versions_input_key_marker(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_object_versions_input_max_keys(
    value: &str,
) -> std::result::Result<std::option::Option<i32>, aws_smithy_http_server::rejection::SmithyRejection>
{
    let value = std::str::FromStr::from_str(value)?;
    Ok(Some(value))
}

pub fn parse_str_list_object_versions_input_prefix(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_object_versions_input_version_id_marker(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_parts_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_parts_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_parts_input_max_parts(
    value: &str,
) -> std::result::Result<std::option::Option<i32>, aws_smithy_http_server::rejection::SmithyRejection>
{
    let value = std::str::FromStr::from_str(value)?;
    Ok(Some(value))
}

pub fn parse_str_list_parts_input_part_number_marker(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_list_parts_input_upload_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_accelerate_configuration_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_acl_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_analytics_configuration_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_analytics_configuration_input_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_cors_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_encryption_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_intelligent_tiering_configuration_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_intelligent_tiering_configuration_input_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_inventory_configuration_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_inventory_configuration_input_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_lifecycle_configuration_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_logging_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_metrics_configuration_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_metrics_configuration_input_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_notification_configuration_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_ownership_controls_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_policy_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_replication_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_request_payment_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_tagging_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_versioning_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_bucket_website_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_object_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_object_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_object_acl_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_object_acl_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_object_acl_input_version_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_object_legal_hold_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_object_legal_hold_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_object_legal_hold_input_version_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_object_lock_configuration_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_object_retention_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_object_retention_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_object_retention_input_version_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_object_tagging_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_object_tagging_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_object_tagging_input_version_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_put_public_access_block_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_restore_object_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_restore_object_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_restore_object_input_version_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_upload_part_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_upload_part_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_upload_part_input_part_number(
    value: &str,
) -> std::result::Result<std::option::Option<i32>, aws_smithy_http_server::rejection::SmithyRejection>
{
    let value = std::str::FromStr::from_str(value)?;
    Ok(Some(value))
}

pub fn parse_str_upload_part_input_upload_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_upload_part_copy_input_bucket(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_upload_part_copy_input_key(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}

pub fn parse_str_upload_part_copy_input_part_number(
    value: &str,
) -> std::result::Result<std::option::Option<i32>, aws_smithy_http_server::rejection::SmithyRejection>
{
    let value = std::str::FromStr::from_str(value)?;
    Ok(Some(value))
}

pub fn parse_str_upload_part_copy_input_upload_id(
    value: &str,
) -> std::result::Result<
    std::option::Option<std::string::String>,
    aws_smithy_http_server::rejection::SmithyRejection,
> {
    let value = <_>::from(
        percent_encoding::percent_decode_str(value)
            .decode_utf8()?
            .as_ref(),
    );
    Ok(Some(value))
}
